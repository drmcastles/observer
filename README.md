## Архитектура системы

- **Observable**  
  Представляет источник данных, поддерживает подписку через Observer.

- **Observer**  
  Обрабатывает элементы, ошибки и завершение.

- **Операторы** (`map`, `filter`, `flatMap`)  
  Создают новые Observable, преобразуя или фильтруя элементы.

- **Schedulers**  
  Управляют потоками выполнения для асинхронной обработки.

- **Disposable**  
  Позволяет отменять подписки и управлять ресурсами.

## Принципы работы Schedulers

- **IOThreadScheduler**  
  Для I/O операций, использует кэшированные потоки.  
  Обладает высокой эффективностью при работе с операциями ввода-вывода, таких как файловые операции или сетевые запросы.

- **ComputationScheduler**  
  Для CPU-интенсивных задач, имеет фиксированное число потоков.  
  Подходит для вычислительно сложных операций, где важно ограничение количества одновременно выполняющихся потоков для оптимального использования процессора.

- **SingleThreadScheduler**  
  Последовательная обработка в одном потоке.  
  Гарантирует, что операции будут выполнены строго по порядку, что полезно, когда важен порядок выполнения задач.

## Процесс тестирования и основные сценарии

- **Проверка корректности преобразований и фильтрации.**  
  Тестируются операторы `map` и `filter` для подтверждения того, что данные преобразуются и фильтруются должным образом.

- **Проверка работы в разных потоках через Schedulers.**  
  Тестируется распределение задач между различными потоками с использованием `IOThreadScheduler`, `ComputationScheduler` и `SingleThreadScheduler`.

- **Обработка ошибок.**  
  Проверяется корректная обработка ошибок через метод `onError` у Observer.

- **Отмена подписок.**  
  Тестирование функционала Disposable для управления ресурсами и отмены подписок в случае необходимости.

## Примеры использования

```java
Observable.create(emitter -> {
    emitter.onNext("Hello");
    emitter.onNext("World");
    emitter.onComplete();
})
.subscribeOn(new IOThreadScheduler())
.observeOn(new ComputationScheduler())
.map(String::toUpperCase)
.filter(s -> s.startsWith("H"))
.subscribe(new Observer<String>() {
    @Override
    public void onNext(String s) {
        System.out.println(s + " on " + Thread.currentThread().getName());
    }

    @Override
    public void onError(Throwable t) {
        t.printStackTrace();
    }

    @Override
    public void onComplete() {
        System.out.println("Done");
    }
});
```
##Заключение
Реализация включает основные компоненты реактивных потоков, управление потоками выполнения и операторы преобразования данных, обеспечивая основу для реактивного программирования
